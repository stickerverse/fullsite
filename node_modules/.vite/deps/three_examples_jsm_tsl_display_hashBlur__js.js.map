{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/hashBlur.js"],
  "sourcesContent": ["import { float, Fn, vec2, uv, sin, rand, degrees, cos, Loop, vec4, premultiplyAlpha, unpremultiplyAlpha, convertToTexture, nodeObject } from 'three/tsl';\n\n/**\n * Applies a hash blur effect to the given texture node.\n *\n * The approach of this blur is different compared to Gaussian and box blur since\n * it does not rely on a kernel to apply a convolution. Instead, it reads the base\n * texture multiple times in a random pattern and then averages the samples. A\n * typical artifact of this technique is a slightly noisy appearance of the blur which\n * can be mitigated by increasing the number of iterations (see `repeats` parameter).\n * Compared to Gaussian blur, hash blur requires just a single pass.\n *\n * Reference: {@link https://www.shadertoy.com/view/4lXXWn}.\n *\n * @function\n * @param {Node<vec4>} textureNode - The texture node that should be blurred.\n * @param {Node<float>} [bluramount=float(0.1)] - This node determines the amount of blur.\n * @param {Object} [options={}] - Additional options for the hash blur effect.\n * @param {Node<float>} [options.repeats=float(45)] - The number of iterations for the blur effect.\n * @param {boolean} [options.premultipliedAlpha=false] - Whether to use premultiplied alpha for the blur effect.\n * @return {Node<vec4>} The blurred texture node.\n */\nexport const hashBlur = /*#__PURE__*/ Fn( ( [ textureNode, bluramount = float( 0.1 ), options = {} ] ) => {\n\n\ttextureNode = convertToTexture( textureNode );\n\n\tconst repeats = nodeObject( options.repeats ) || float( 45 );\n\tconst premultipliedAlpha = options.premultipliedAlpha || false;\n\n\tconst tap = ( uv ) => {\n\n\t\tconst sample = textureNode.sample( uv );\n\n\t\treturn premultipliedAlpha ? premultiplyAlpha( sample ) : sample;\n\n\t};\n\n\tconst targetUV = textureNode.uvNode || uv();\n\tconst blurred_image = vec4( 0. );\n\n\tLoop( { start: 0., end: repeats, type: 'float' }, ( { i } ) => {\n\n\t\tconst q = vec2( vec2( cos( degrees( i.div( repeats ).mul( 360. ) ) ), sin( degrees( i.div( repeats ).mul( 360. ) ) ) ).mul( rand( vec2( i, targetUV.x.add( targetUV.y ) ) ).add( bluramount ) ) );\n\t\tconst uv2 = vec2( targetUV.add( q.mul( bluramount ) ) );\n\t\tblurred_image.addAssign( tap( uv2 ) );\n\n\t} );\n\n\tblurred_image.divAssign( repeats );\n\n\treturn premultipliedAlpha ? unpremultiplyAlpha( blurred_image ) : blurred_image;\n\n} );\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAsBO,IAAM,WAAyB,GAAI,CAAE,CAAE,aAAa,aAAa,MAAO,GAAI,GAAG,UAAU,CAAC,CAAE,MAAO;AAEzG,gBAAc,iBAAkB,WAAY;AAE5C,QAAM,UAAU,WAAY,QAAQ,OAAQ,KAAK,MAAO,EAAG;AAC3D,QAAM,qBAAqB,QAAQ,sBAAsB;AAEzD,QAAM,MAAM,CAAEA,QAAQ;AAErB,UAAM,SAAS,YAAY,OAAQA,GAAG;AAEtC,WAAO,qBAAqB,iBAAkB,MAAO,IAAI;AAAA,EAE1D;AAEA,QAAM,WAAW,YAAY,UAAU,GAAG;AAC1C,QAAM,gBAAgB,KAAM,CAAG;AAE/B,OAAM,EAAE,OAAO,GAAI,KAAK,SAAS,MAAM,QAAQ,GAAG,CAAE,EAAE,EAAE,MAAO;AAE9D,UAAM,IAAI,KAAM,KAAM,IAAK,QAAS,EAAE,IAAK,OAAQ,EAAE,IAAK,GAAK,CAAE,CAAE,GAAG,IAAK,QAAS,EAAE,IAAK,OAAQ,EAAE,IAAK,GAAK,CAAE,CAAE,CAAE,EAAE,IAAK,KAAM,KAAM,GAAG,SAAS,EAAE,IAAK,SAAS,CAAE,CAAE,CAAE,EAAE,IAAK,UAAW,CAAE,CAAE;AAChM,UAAM,MAAM,KAAM,SAAS,IAAK,EAAE,IAAK,UAAW,CAAE,CAAE;AACtD,kBAAc,UAAW,IAAK,GAAI,CAAE;AAAA,EAErC,CAAE;AAEF,gBAAc,UAAW,OAAQ;AAEjC,SAAO,qBAAqB,mBAAoB,aAAc,IAAI;AAEnE,CAAE;",
  "names": ["uv"]
}
