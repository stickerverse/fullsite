{
  "version": 3,
  "sources": ["../../gsap/dist/SplitText.js"],
  "sourcesContent": ["/*!\n * SplitText 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.\n * @author: Jack Doyle\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.window = global.window || {}));\n})(this, (function (exports) { 'use strict';\n\n\tlet gsap, _fonts, _coreInitted, _initIfNecessary = () => _coreInitted || SplitText.register(window.gsap), _charSegmenter = typeof Intl !== \"undefined\" ? new Intl.Segmenter() : 0, _toArray = (r) => typeof r === \"string\" ? _toArray(document.querySelectorAll(r)) : \"length\" in r ? Array.from(r) : [r], _elements = (targets) => _toArray(targets).filter((e) => e instanceof HTMLElement), _emptyArray = [], _context = function() {\n\t}, _spacesRegEx = /\\s+/g, _emojiSafeRegEx = new RegExp(\"\\\\p{RI}\\\\p{RI}|\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?(\\\\u{200D}\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?)*|.\", \"gu\"), _emptyBounds = { left: 0, top: 0, width: 0, height: 0 }, _stretchToFitSpecialChars = (collection, specialCharsRegEx) => {\n\t  if (specialCharsRegEx) {\n\t    let charsFound = new Set(collection.join(\"\").match(specialCharsRegEx) || _emptyArray), i = collection.length, slots, word, char, combined;\n\t    if (charsFound.size) {\n\t      while (--i > -1) {\n\t        word = collection[i];\n\t        for (char of charsFound) {\n\t          if (char.startsWith(word) && char.length > word.length) {\n\t            slots = 0;\n\t            combined = word;\n\t            while (char.startsWith(combined += collection[i + ++slots]) && combined.length < char.length) {\n\t            }\n\t            if (slots && combined.length === char.length) {\n\t              collection[i] = char;\n\t              collection.splice(i + 1, slots);\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return collection;\n\t}, _disallowInline = (element) => window.getComputedStyle(element).display === \"inline\" && (element.style.display = \"inline-block\"), _insertNodeBefore = (newChild, parent, existingChild) => parent.insertBefore(typeof newChild === \"string\" ? document.createTextNode(newChild) : newChild, existingChild), _getWrapper = (type, config, collection) => {\n\t  let className = config[type + \"sClass\"] || \"\", { tag = \"div\", aria = \"auto\", propIndex = false } = config, display = type === \"line\" ? \"block\" : \"inline-block\", incrementClass = className.indexOf(\"++\") > -1, wrapper = (text) => {\n\t    let el = document.createElement(tag), i = collection.length + 1;\n\t    className && (el.className = className + (incrementClass ? \" \" + className + i : \"\"));\n\t    propIndex && el.style.setProperty(\"--\" + type, i + \"\");\n\t    aria !== \"none\" && el.setAttribute(\"aria-hidden\", \"true\");\n\t    if (tag !== \"span\") {\n\t      el.style.position = \"relative\";\n\t      el.style.display = display;\n\t    }\n\t    el.textContent = text;\n\t    collection.push(el);\n\t    return el;\n\t  };\n\t  incrementClass && (className = className.replace(\"++\", \"\"));\n\t  wrapper.collection = collection;\n\t  return wrapper;\n\t}, _getLineWrapper = (element, nodes, config, collection) => {\n\t  let lineWrapper = _getWrapper(\"line\", config, collection), textAlign = window.getComputedStyle(element).textAlign || \"left\";\n\t  return (startIndex, endIndex) => {\n\t    let newLine = lineWrapper(\"\");\n\t    newLine.style.textAlign = textAlign;\n\t    element.insertBefore(newLine, nodes[startIndex]);\n\t    for (; startIndex < endIndex; startIndex++) {\n\t      newLine.appendChild(nodes[startIndex]);\n\t    }\n\t    newLine.normalize();\n\t  };\n\t}, _splitWordsAndCharsRecursively = (element, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, isNested) => {\n\t  var _a;\n\t  let nodes = Array.from(element.childNodes), i = 0, { wordDelimiter, reduceWhiteSpace = true, prepareText } = config, elementBounds = element.getBoundingClientRect(), lastBounds = elementBounds, isPreformatted = !reduceWhiteSpace && window.getComputedStyle(element).whiteSpace.substring(0, 3) === \"pre\", ignoredPreviousSibling = 0, wordsCollection = wordWrapper.collection, wordDelimIsNotSpace, wordDelimString, wordDelimSplitter, curNode, words, curWordEl, startsWithSpace, endsWithSpace, j, bounds, curWordChars, clonedNode, curSubNode, tempSubNode, curTextContent, wordText, lastWordText, k;\n\t  if (typeof wordDelimiter === \"object\") {\n\t    wordDelimSplitter = wordDelimiter.delimiter || wordDelimiter;\n\t    wordDelimString = wordDelimiter.replaceWith || \"\";\n\t  } else {\n\t    wordDelimString = wordDelimiter === \"\" ? \"\" : wordDelimiter || \" \";\n\t  }\n\t  wordDelimIsNotSpace = wordDelimString !== \" \";\n\t  for (; i < nodes.length; i++) {\n\t    curNode = nodes[i];\n\t    if (curNode.nodeType === 3) {\n\t      curTextContent = curNode.textContent || \"\";\n\t      if (reduceWhiteSpace) {\n\t        curTextContent = curTextContent.replace(_spacesRegEx, \" \");\n\t      } else if (isPreformatted) {\n\t        curTextContent = curTextContent.replace(/\\n/g, wordDelimString + \"\\n\");\n\t      }\n\t      prepareText && (curTextContent = prepareText(curTextContent, element));\n\t      curNode.textContent = curTextContent;\n\t      words = wordDelimString || wordDelimSplitter ? curTextContent.split(wordDelimSplitter || wordDelimString) : curTextContent.match(charSplitRegEx) || _emptyArray;\n\t      lastWordText = words[words.length - 1];\n\t      endsWithSpace = wordDelimIsNotSpace ? lastWordText.slice(-1) === \" \" : !lastWordText;\n\t      lastWordText || words.pop();\n\t      lastBounds = elementBounds;\n\t      startsWithSpace = wordDelimIsNotSpace ? words[0].charAt(0) === \" \" : !words[0];\n\t      startsWithSpace && _insertNodeBefore(\" \", element, curNode);\n\t      words[0] || words.shift();\n\t      _stretchToFitSpecialChars(words, specialCharsRegEx);\n\t      deepSlice && isNested || (curNode.textContent = \"\");\n\t      for (j = 1; j <= words.length; j++) {\n\t        wordText = words[j - 1];\n\t        if (!reduceWhiteSpace && isPreformatted && wordText.charAt(0) === \"\\n\") {\n\t          (_a = curNode.previousSibling) == null ? void 0 : _a.remove();\n\t          _insertNodeBefore(document.createElement(\"br\"), element, curNode);\n\t          wordText = wordText.slice(1);\n\t        }\n\t        if (!reduceWhiteSpace && wordText === \"\") {\n\t          _insertNodeBefore(wordDelimString, element, curNode);\n\t        } else if (wordText === \" \") {\n\t          element.insertBefore(document.createTextNode(\" \"), curNode);\n\t        } else {\n\t          wordDelimIsNotSpace && wordText.charAt(0) === \" \" && _insertNodeBefore(\" \", element, curNode);\n\t          if (ignoredPreviousSibling && j === 1 && !startsWithSpace && wordsCollection.indexOf(ignoredPreviousSibling.parentNode) > -1) {\n\t            curWordEl = wordsCollection[wordsCollection.length - 1];\n\t            curWordEl.appendChild(document.createTextNode(charWrapper ? \"\" : wordText));\n\t          } else {\n\t            curWordEl = wordWrapper(charWrapper ? \"\" : wordText);\n\t            _insertNodeBefore(curWordEl, element, curNode);\n\t            ignoredPreviousSibling && j === 1 && !startsWithSpace && curWordEl.insertBefore(ignoredPreviousSibling, curWordEl.firstChild);\n\t          }\n\t          if (charWrapper) {\n\t            curWordChars = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(wordText)].map((s) => s.segment), specialCharsRegEx) : wordText.match(charSplitRegEx) || _emptyArray;\n\t            for (k = 0; k < curWordChars.length; k++) {\n\t              curWordEl.appendChild(curWordChars[k] === \" \" ? document.createTextNode(\" \") : charWrapper(curWordChars[k]));\n\t            }\n\t          }\n\t          if (deepSlice && isNested) {\n\t            curTextContent = curNode.textContent = curTextContent.substring(wordText.length + 1, curTextContent.length);\n\t            bounds = curWordEl.getBoundingClientRect();\n\t            if (bounds.top > lastBounds.top && bounds.left <= lastBounds.left) {\n\t              clonedNode = element.cloneNode();\n\t              curSubNode = element.childNodes[0];\n\t              while (curSubNode && curSubNode !== curWordEl) {\n\t                tempSubNode = curSubNode;\n\t                curSubNode = curSubNode.nextSibling;\n\t                clonedNode.appendChild(tempSubNode);\n\t              }\n\t              element.parentNode.insertBefore(clonedNode, element);\n\t              prepForCharsOnly && _disallowInline(clonedNode);\n\t            }\n\t            lastBounds = bounds;\n\t          }\n\t          if (j < words.length || endsWithSpace) {\n\t            _insertNodeBefore(j >= words.length ? \" \" : wordDelimIsNotSpace && wordText.slice(-1) === \" \" ? \" \" + wordDelimString : wordDelimString, element, curNode);\n\t          }\n\t        }\n\t      }\n\t      element.removeChild(curNode);\n\t      ignoredPreviousSibling = 0;\n\t    } else if (curNode.nodeType === 1) {\n\t      if (ignore && ignore.indexOf(curNode) > -1) {\n\t        wordsCollection.indexOf(curNode.previousSibling) > -1 && wordsCollection[wordsCollection.length - 1].appendChild(curNode);\n\t        ignoredPreviousSibling = curNode;\n\t      } else {\n\t        _splitWordsAndCharsRecursively(curNode, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, true);\n\t        ignoredPreviousSibling = 0;\n\t      }\n\t      prepForCharsOnly && _disallowInline(curNode);\n\t    }\n\t  }\n\t};\n\tconst _SplitText = class _SplitText {\n\t  constructor(elements, config) {\n\t    this.isSplit = false;\n\t    _initIfNecessary();\n\t    this.elements = _elements(elements);\n\t    this.chars = [];\n\t    this.words = [];\n\t    this.lines = [];\n\t    this.masks = [];\n\t    this.vars = config;\n\t    this._split = () => this.isSplit && this.split(this.vars);\n\t    let orig = [], timerId, checkWidths = () => {\n\t      let i = orig.length, o;\n\t      while (i--) {\n\t        o = orig[i];\n\t        let w = o.element.offsetWidth;\n\t        if (w !== o.width) {\n\t          o.width = w;\n\t          this._split();\n\t          return;\n\t        }\n\t      }\n\t    };\n\t    this._data = { orig, obs: typeof ResizeObserver !== \"undefined\" && new ResizeObserver(() => {\n\t      clearTimeout(timerId);\n\t      timerId = setTimeout(checkWidths, 200);\n\t    }) };\n\t    _context(this);\n\t    this.split(config);\n\t  }\n\t  split(config) {\n\t    this.isSplit && this.revert();\n\t    this.vars = config = config || this.vars || {};\n\t    let { type = \"chars,words,lines\", aria = \"auto\", deepSlice = true, smartWrap, onSplit, autoSplit = false, specialChars, mask } = this.vars, splitLines = type.indexOf(\"lines\") > -1, splitCharacters = type.indexOf(\"chars\") > -1, splitWords = type.indexOf(\"words\") > -1, onlySplitCharacters = splitCharacters && !splitWords && !splitLines, specialCharsRegEx = specialChars && (\"push\" in specialChars ? new RegExp(\"(?:\" + specialChars.join(\"|\") + \")\", \"gu\") : specialChars), finalCharSplitRegEx = specialCharsRegEx ? new RegExp(specialCharsRegEx.source + \"|\" + _emojiSafeRegEx.source, \"gu\") : _emojiSafeRegEx, ignore = !!config.ignore && _elements(config.ignore), { orig, animTime, obs } = this._data, onSplitResult;\n\t    if (splitCharacters || splitWords || splitLines) {\n\t      this.elements.forEach((element, index) => {\n\t        orig[index] = {\n\t          element,\n\t          html: element.innerHTML,\n\t          ariaL: element.getAttribute(\"aria-label\"),\n\t          ariaH: element.getAttribute(\"aria-hidden\")\n\t        };\n\t        aria === \"auto\" ? element.setAttribute(\"aria-label\", (element.textContent || \"\").trim()) : aria === \"hidden\" && element.setAttribute(\"aria-hidden\", \"true\");\n\t        let chars = [], words = [], lines = [], charWrapper = splitCharacters ? _getWrapper(\"char\", config, chars) : null, wordWrapper = _getWrapper(\"word\", config, words), i, curWord, smartWrapSpan, nextSibling;\n\t        _splitWordsAndCharsRecursively(element, config, wordWrapper, charWrapper, onlySplitCharacters, deepSlice && (splitLines || onlySplitCharacters), ignore, finalCharSplitRegEx, specialCharsRegEx, false);\n\t        if (splitLines) {\n\t          let nodes = _toArray(element.childNodes), wrapLine = _getLineWrapper(element, nodes, config, lines), curNode, toRemove = [], lineStartIndex = 0, allBounds = nodes.map((n) => n.nodeType === 1 ? n.getBoundingClientRect() : _emptyBounds), lastBounds = _emptyBounds;\n\t          for (i = 0; i < nodes.length; i++) {\n\t            curNode = nodes[i];\n\t            if (curNode.nodeType === 1) {\n\t              if (curNode.nodeName === \"BR\") {\n\t                toRemove.push(curNode);\n\t                wrapLine(lineStartIndex, i + 1);\n\t                lineStartIndex = i + 1;\n\t                lastBounds = allBounds[lineStartIndex];\n\t              } else {\n\t                if (i && allBounds[i].top > lastBounds.top && allBounds[i].left <= lastBounds.left) {\n\t                  wrapLine(lineStartIndex, i);\n\t                  lineStartIndex = i;\n\t                }\n\t                lastBounds = allBounds[i];\n\t              }\n\t            }\n\t          }\n\t          lineStartIndex < i && wrapLine(lineStartIndex, i);\n\t          toRemove.forEach((el) => {\n\t            var _a;\n\t            return (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);\n\t          });\n\t        }\n\t        if (!splitWords) {\n\t          for (i = 0; i < words.length; i++) {\n\t            curWord = words[i];\n\t            if (splitCharacters || !curWord.nextSibling || curWord.nextSibling.nodeType !== 3) {\n\t              if (smartWrap && !splitLines) {\n\t                smartWrapSpan = document.createElement(\"span\");\n\t                smartWrapSpan.style.whiteSpace = \"nowrap\";\n\t                while (curWord.firstChild) {\n\t                  smartWrapSpan.appendChild(curWord.firstChild);\n\t                }\n\t                curWord.replaceWith(smartWrapSpan);\n\t              } else {\n\t                curWord.replaceWith(...curWord.childNodes);\n\t              }\n\t            } else {\n\t              nextSibling = curWord.nextSibling;\n\t              if (nextSibling && nextSibling.nodeType === 3) {\n\t                nextSibling.textContent = (curWord.textContent || \"\") + (nextSibling.textContent || \"\");\n\t                curWord.remove();\n\t              }\n\t            }\n\t          }\n\t          words.length = 0;\n\t          element.normalize();\n\t        }\n\t        this.lines.push(...lines);\n\t        this.words.push(...words);\n\t        this.chars.push(...chars);\n\t      });\n\t      mask && this[mask] && this.masks.push(...this[mask].map((el) => {\n\t        let maskEl = el.cloneNode();\n\t        el.replaceWith(maskEl);\n\t        maskEl.appendChild(el);\n\t        el.className && (maskEl.className = el.className.replace(/(\\b\\w+\\b)/g, \"$1-mask\"));\n\t        maskEl.style.overflow = \"clip\";\n\t        return maskEl;\n\t      }));\n\t    }\n\t    this.isSplit = true;\n\t    _fonts && (autoSplit ? _fonts.addEventListener(\"loadingdone\", this._split) : _fonts.status === \"loading\" && console.warn(\"SplitText called before fonts loaded\"));\n\t    if ((onSplitResult = onSplit && onSplit(this)) && onSplitResult.totalTime) {\n\t      this._data.anim = animTime ? onSplitResult.totalTime(animTime) : onSplitResult;\n\t    }\n\t    splitLines && autoSplit && this.elements.forEach((element, index) => {\n\t      orig[index].width = element.offsetWidth;\n\t      obs && obs.observe(element);\n\t    });\n\t    return this;\n\t  }\n\t  revert() {\n\t    var _a, _b;\n\t    let { orig, anim, obs } = this._data;\n\t    obs && obs.disconnect();\n\t    orig.forEach(({ element, html, ariaL, ariaH }) => {\n\t      element.innerHTML = html;\n\t      ariaL ? element.setAttribute(\"aria-label\", ariaL) : element.removeAttribute(\"aria-label\");\n\t      ariaH ? element.setAttribute(\"aria-hidden\", ariaH) : element.removeAttribute(\"aria-hidden\");\n\t    });\n\t    this.chars.length = this.words.length = this.lines.length = orig.length = this.masks.length = 0;\n\t    this.isSplit = false;\n\t    _fonts == null ? void 0 : _fonts.removeEventListener(\"loadingdone\", this._split);\n\t    if (anim) {\n\t      this._data.animTime = anim.totalTime();\n\t      anim.revert();\n\t    }\n\t    (_b = (_a = this.vars).onRevert) == null ? void 0 : _b.call(_a, this);\n\t    return this;\n\t  }\n\t  static create(elements, config) {\n\t    return new _SplitText(elements, config);\n\t  }\n\t  static register(core) {\n\t    gsap = gsap || core || window.gsap;\n\t    if (gsap) {\n\t      _toArray = gsap.utils.toArray;\n\t      _context = gsap.core.context || _context;\n\t    }\n\t    if (!_coreInitted && window.innerWidth > 0) {\n\t      _fonts = document.fonts;\n\t      _coreInitted = true;\n\t    }\n\t  }\n\t};\n\t_SplitText.version = \"3.13.0\";\n\tlet SplitText = _SplitText;\n\n\texports.SplitText = SplitText;\n\texports.default = SplitText;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],
  "mappings": "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",
  "names": ["exports", "_SplitText"]
}
